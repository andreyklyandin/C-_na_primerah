
// C++_na_primerah.cpp : Этот файл содержит практическое решение задач из книги "С++ на примерах"
// 
//

#include <iostream>
#include <string>
#include <Windows.h>
#include <cmath>



using std::cout;
using std::string;
using std::endl;
using std::cin;
                            
                             

 // Листинг 5.1 является ли число четым.
 
void Аn_even_number()
{
  int number{};

  cout << "Введите число: ";

  cin >> number;

  if (number % 2 == 0)                                                         // Используем оператор %, который позволяет узнать остаток от деления.
    cout << "\nВведёное число " << number << " является четным";
  else 
    cout << "\nВведёное число " << number << " является нечетным";

  cout << endl;
}


 // Листинг 5.2. Максимум среди трех чисел.

void Max_3_number()
{
  int number_1{};
  int number_2{};
  int number_3{};
  int number_Max{};

  cout << "\nВведите первое целое число: ";
  cin >> number_1;

  cout << "\nВведите второе целое число: ";
  cin >> number_2;

  cout << "\nВведите второе целое число: ";
  cin >> number_3;

  if ( number_1 >= number_2 && number_1 >= number_3 )      // Используем оператор && ( И ).
    number_Max = number_1;

  if ( number_2 >= number_1 && number_2 >= number_3 )
    number_Max = number_2;

  if ( number_3 >= number_2 && number_3 >= number_1 )
    number_Max = number_3;

  cout << "Максимальное чило из введёных является число: " << number_Max << endl;

  cout << endl;
}


 // Листинг 5.3 Вычисляем все корни квадратного уравнения 
  
void The_square_root()
{  
  /* Стандартная форма квадратного уравнения выглядит так: 
         
         ax^2 + bx + c = 0, 

         где а, b, c - вещественные числа, и a - не равно 0.

   Термин b^2 - 4ac также известен как детерменант квадратного уравнения.
   Детерминант позволяет определить природу корней:
     
     - Если детерминант больше 0, корни являются вещественными и они разные. Корней два.

     - Если детерминант равен 0, корни вещественные и одинаковые. Корень, по сути, один.
     
     - Если детерминант меньше 0, корни являются комплекнсгыми и разными. Всего еорней два. */
  cout << endl << "                                            РЕШЕНИЕ КВАДРАТНОГО УРАВНЕНИЯ    " << endl << endl << endl;

  float a, b, c{};                                // коофициенты уравнения.

  float x1, x2{};                               // корни квадратного уравнения.

  float discrivinant{};                      // переменная значения дискриминанта

  float realPart{};                       // реальная часть комплексного  корня

  float imaginatyPart{};                // мнимая чаять комплексного корня

  cout << "Вводим коофициенты уравнения - введите коофицент а:  ";
  cin >> a;  cout << endl;

    cout << "Введите коофицент b:  ";
    cin >> b;  cout << endl;

    cout << "Введите коофицент b:  ";
    cin >> c;  cout << endl;

  discrivinant = b * b - 4 * a * c;     // Вычисляем детерменант

  cout << "Дискриминант равен: " << discrivinant << endl;

  if (discrivinant > 0)
    { 
     x1 = (-b + sqrt(discrivinant)) / (2 * a);
     x2 = (-b - sqrt(discrivinant)) / (2 * a);

     cout << "Так как дискриминант больше 0, то корни данного уравнения являются вещественные и они разные." << endl;
     cout << "x1 = " << x1 << endl;
     cout << "x2 = " << x2 << endl;
    }

  else if (discrivinant == 0)
  {
    x1 = (-b + sqrt(discrivinant)) / (2 * a);

    cout << "Так как дискриминант равен  0, то корни данного уравнения являются вещественные и они одинаковые." << endl;
    cout << "x1 = x2 = " << x1 << endl;
  }

  else 
     {
       realPart = -b/ (2 * a);
       imaginatyPart = sqrt(discrivinant) / (2 * a);

       cout << "Так как дискриминант меньше  0, то корни данного уравнения являются комплексными и они разные." << endl << endl;
       cout << "x1 = " << realPart << "+" << imaginatyPart << "i" << endl;
       cout << "x2 = " << realPart << "-" << imaginatyPart << "i" << endl;
     }

  cout << endl << endl << endl;

}

// Листинг 5.4 Является ли код високосным ?

void Leap_year()
{
  /* Эта программма определяет является ли год, введёный пользователем с клвиатуры високосным.
     
     Високосные года ( в которых есть 29 февраля и,соответственно - 366 дней ) - это те, которые делятся на 4 без остатка: 2004,2008,20012,2016,2020,2024 и т.д
     
     Однако, в григореанском католическом календаре, по которому мы ныне живем ("новый стиль") есть еще редкое и малоизвестное правило: те года, которые 
     нацело делятся на 100 ( т.е оканчиваются -00) и котрорые делятся на 400 - високосные, а которые делятся с остатком - не високосные.
     
     Поэтому 17000, 1800, 1900 года были невисокосными ( хотя и делятся нацело на 4 ), 2000 - был високосным как обычно ( делится нацело на 400),
     2100, 2200, 2300 - так же будут невисокосными.*/

  cout << "                                   ОПРЕДЕЛЕНИИ ВИСОКОСНОГО ГОДА." << endl << endl;

  int year{};

  cout << "Введите год интерисующий вас год: " ;
  cin >> year;

  cout << endl;

  if ( year % 4 == 0 )
  {
    if (year % 100 == 0)
    {
      if (year % 400 == 0)
        cout <<" " << year << " год является високосным";
      else
        cout << " " << year << " год является не високосным";
    }
    else
      cout << " " << year << "год является не високосным";
  }
  else
    cout << " " << year << " год является не високосным";

  cout << endl << endl << endl;
}

// Листинг 5.5 Простой калькулятор                     Пример использования оператора switch.

void Calculation()
{     
  while (true)
  {

 
  cout << "                                        ПРОСТЙШИЙ КАЛЬКУЛЯТОР" << endl << endl;

  char operand{};

  float num1{}, num2{};

  cout << "Введите первый операнд: ";
    cin >> num1;

    cout << endl;
     
  cout << "Введите второй операнд: ";
    cin >> num2;


  cout << endl << "Введите  оператор ( +, -, /, *):  ";
   cin >> operand;

   switch (operand)
   {
   case'+':
       cout << endl << "Результат сложения равен:   " << num1 + num2 << endl << endl;
       system("pause");                                                                         // Эта команда нужна для задержки строки текста на на консоли
       system("cls");                                                                          // Эта команда очищает консоль. 
       break;                                                                                 // Потом программа выходит из цикла switch и переодит в начало цикла while и
                                                                                             //  програма зупускает цикл с ввода первого операнда. 
   case'-':
     cout << endl << "Результат вычитания равен:   " << num1 - num2 << endl << endl;
     system("pause");
     system("cls");
     break;
    
   case'/':

     if (num2 == 0)

     {
       cout << endl << "На ноль делить нельзя !!!!" << endl << endl;
       system("pause");
       system("cls");
       break;
     }
     else 
       cout << endl << "Результат деления равен:   " << num1 / num2 << endl << endl;
       system("pause");
       system("cls");
     break;

   case'*':
     cout << endl << "Результат умножения равен:   " << num1 * num2 << endl << endl;
     system("pause");
     system("cls");
     break;

   default:

       cout << endl<< "Вы ввели недопустимый оператор !!!!" << endl << endl;
       system("pause");
       system("cls");
     break;
   }
  
  }
}

                            
                                                               /* ОПЕРАТОРЫ ЦИКЛА*/
                                                /* В языке С++ предусмотрено три оператора цикла:
                                                     
                                                               - Оператор for
                                                               
                                                               - Операьор while
                                                               
                                                               - Оператор do while                */

 
       // Листинг 5.6 Вычесление суммы натуральных чисел с помщщью цикла for             !!!!!!! До работать !!!!!!

void The_sum_of_natural_numbers()
{
  /* Эта программа вычисляет сумму всех натуральных чисел от 1 до n, которое введёт пользователь с клавиаткры*/




  cout << endl << "                                         ВЫЧМСЛЕНИЕ СУММЫ НАТУРАЛЬНЫХ ЧИСЕЛ" << endl << endl;

  int number{};

  int summa{};

  cout << "Введите целое положительное число: ";
  cin >> number;

  cout << endl << endl;

  if (number == 0 || number < 0)
  {
    cout << "Вы ввели неподходящее число.";
  }
  else

    for (int i = 0; i <= number; ++i)
    {
      summa += i;
    }
  

  cout << "Сумма всех чисел до числа  " << number << " (включительно) равна  -  " << summa;




  cout << endl << endl;
  system("pause");
}

    // Листинг 5.7 Создание пирамиды из звездочек.                       // Вложенные циклы.

void Pyramid_of_stars()
{
  int rows{};

  cout << "Введите количество строк:  ";
  cin >> rows;

  for (int i = 1; i <= rows; ++i)                      // Внешний цикл. Задаёт количество строк.
  {
    for (int j = rows; j > i; --j)
    {
         cout << "* ";
    }
    cout << endl;
  }

  
}

  // Листинг 5.8 Сумма натуральных чисел с помощью цикла while.

 void Sum_numbers()
{
  cout << endl << "                            ВЫЧИСЛЕНИЕ СУММЫ ЧИСЕЛ ПРИ ПОМОЩИ ЦИКЛА while" << endl << endl << endl;
  int number{};

  cout << "Ведите любой натуральное целое число: ";
  cin >> number;

  int i{1};
  int sum{};
  while (i <= number)
  {
     sum += i;
     ++i;
  }

  cout << endl << endl <<"Сумма чисел равна: " << sum << endl << endl;

}



   /*                                                  5.3 СОВМЕСТНОЕ ИСПОЛЬЗОВАНИЕ ОПЕРАТОРОВ ЦИКЛА И УСЛОВНЫХ ОПЕРАТОРОВ                                                                     */



 // Листинг 5.10 Вычисление последовательности Фибоначи.

 void The_Fibonacci_sequence()
 {
      /* Эта программа выводит заданное количество чисел Фибоначи. 
      
        Числа Фибоначи - элементы последовательности целых чисел, в которой каждое последующее число равно сумме двух предыдущих чисел.
        Начинается последовательность с 0 и 1.*/

   cout << endl << "                               ВЫЧИСЛЕНИЕ ПОСЛЕДОВАТЕЛЬНОСТИ ЧИСЕЛ ФИБОНАЧИ" << endl << endl;

   int number{};                       // Переменная для задания количества элементов последовательности.

   int number_1{};
   int number_2{ 1 };
   int nextTerm{};

   cout << "Введите количество элементов последовательности: ";
   cin >> number;

   cout << endl << "Последовательность Фибоначи: ";

   for (int i{1}; i <= number; ++i)
   {
     // Выводим первый элемент
     if (i == 1)
     {
       cout << " " << number_1;
       continue;
     }
     if (i == 2)
     {
       cout << number_2 << " ";
       continue;
     }
     nextTerm = number_1 + number_2;
     number_1 = number_2;
     number_2 = nextTerm;

     cout  << nextTerm << " ";
    }
   cout << endl;
 }

//      ---  Вариант, когда последовательность нужно сгенерировать до определенного числа.  ------    

 void The_Fibonacci_sequence_number()
 {
   cout << endl << "                               ВЫЧИСЛЕНИЕ ПОСЛЕДОВАТЕЛЬНОСТИ ЧИСЕЛ ФИБОНАЧИ" << endl ;
   cout << "                                            до определенного числа" << endl << endl;

   int number{};                       // Переменная числа, до которого нужно сгенерировать  последовательность.

   int number_1{};
   int number_2{ 1 };
   int nextTerm{};


   cout << "Введите целое положительное число: ";
   cin >> number;

   cout << "Последовательность числа Фибоначи до числа " << number << " : " << number_1 << ", " << number_2 << ", ";


   nextTerm = number_1 + number_2;

   while (nextTerm <= number)
   {
     cout << nextTerm << ", ";
     number_1 = number_2;
     number_2 = nextTerm;
     nextTerm = number_1 + number_2;
   }

   cout << endl;
 }    




/*                                             5.4 ДОПОЛНИТЕЛЬНЫЕ ПРАКТИЧЕСКИЕ ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ ЦИКЛОВ И ДОПОЛНИТЕЛЬНЫХ ОПЕРАТОРОВ                                                             */

  
  

     // Листинг 5.11  Определение Наибольшего общего делителя (НОД) с помощью цикла for

 void The_largest_common_divisor()
 {
   /*     НОД двух чисел - это максимальное чмсло, на которое могут быть разделены оба числа. Пример: для чисел 770 и 105 наибольший общий делитель равен 35 
            
          Существует множество способов определить НОД програмно. Первый способ заключается в использовании цикла for. В нем перебираем делители  в порядке возрастания: если будет найден такой, на
          который делятся без остатка оба числа, мы будем считать его общим делителем. Поскольку делители перебираются в порядке возрастания, то последний общий делитель будет наибольшим.*/



   cout << endl << "                             ОПРЕДЕЛЕНИЕ НОД С ПОМОЩЬЮ ЦИКЛА for" << endl << endl;



   int hcf{};                       // НОД.

   int number_1{};
   int number_2{};

   cout << "Введите первое число:  ";
   cin >> number_1;
   
   cout << endl << "Введите второе число:  ";
   cin >> number_2;

   // Если *number_2* > *number_1*, то меняем их местами.

   if (number_2 > number_1)
   {
     int temp = number_2;
     number_2 = number_1;
     number_1 = temp;
   }

   for (int i = 1; i <= number_2; ++i)
   {
     if (number_1 % i == 0 && number_2 % i == 0)
       hcf = i;
   }

   cout << endl << "НОД = " << hcf << endl;
 }
int main()
{
  SetConsoleCP(1251);
  SetConsoleOutputCP(1251);


  //Аn_even_number();                                                      // Листинг 5.1 является ли число четым.

 // Max_3_number();

  //The_square_root();

  //Leap_year();

  //Calculation();

  //The_sum_of_natural_numbers();

  //Pyramid_of_stars();

  //Sum_numbers();

  //The_Fibonacci_sequence();

  //The_Fibonacci_sequence_number();

  The_largest_common_divisor();


    //std::cout << "Hello World!\n";

  cout << endl << endl << endl;
}















// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
